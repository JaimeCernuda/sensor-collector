\section{Introduction}

The growing demands of distributed applications have driven a need for tightly synchronized clocks on commodity hardware. Instead of coordinating over the network, applications can establish event ordering using timestamps from local clocks, but only if those clocks are sufficiently accurate. Distributed tracing systems from Dapper~\cite{dapper_google2010} onward depend on synchronized timestamps to reconstruct causal order across services. Microservice observability frameworks face the same challenge: XPLOG documents that preserving causal ordering across asynchronous microservices remains difficult~\cite{xplog_tsc2026}. Agentic AI systems intensify the problem, orchestrating chains of asynchronous events across services where even modest clock skew can corrupt execution traces. As application latencies tighten, the accuracy limitations of commodity oscillators become a bottleneck. Achieving sub-millisecond accuracy has traditionally required specialized infrastructure such as PTP-capable network interfaces, GPS receivers, or atomic references~\cite{ptp}, yet commodity servers, edge deployments, and heterogeneous clusters lack access to such hardware. Software-based compensation of the local oscillator offers an alternative path: correcting drift using sensors already present on commodity motherboards.

Between synchronization events, commodity servers free-run on local quartz oscillators whose frequency varies with temperature, supply voltage, and aging~\cite{tirado_andres_clock_sources_2019}. NTP~\cite{ntp} periodically corrects clock offset over the network, but drift accumulates to tens or hundreds of microseconds during holdover. Hardware solutions such as PTP-synchronized networks, GPS-disciplined references, and atomic clocks can achieve nanosecond-level accuracy; datacenter systems such as Sundial~\cite{sundial_osdi2020} and Huygens~\cite{huygens_nsdi2018_geng_svm_nanosec} demonstrate what becomes possible with dedicated timing infrastructure. For the vast majority of commodity deployments where such infrastructure is impractical, software compensation has emerged as a practical alternative. Chrony's \texttt{tempcomp} directive applies a static polynomial to a single temperature reading, providing modest improvement. Graham~\cite{graham_nsdi22} advanced this dramatically, demonstrating that automatic cubic polynomial fitting to DIMM temperature readings could reduce commodity oscillator drift by three orders of magnitude. Across adjacent domains, machine learning has since shown consistent improvements over polynomial baselines for clock and oscillator prediction~\cite{he_bds3_lstm_72pct_arima, gnss_clock_prediction_review_2025}.

Yet existing software compensation approaches share unsolved dimensions that constrain practical deployment. Per-device calibration remains a barrier, with current systems requiring extended learning periods per server before compensation can begin~\cite{graham_nsdi22, su_lstm_tcxo_transfer_learning}. Current methods are designed for single-variable correction, typically relying on a single temperature sensor without addressing the joint dynamics of other node variables such as CPU load, operating frequency, and power consumption~\cite{tirado_andres_clock_sources_2019}. Once the compensation model is fit, it remains fixed; crystal behavior changes over time due to aging, thermal history, and environmental shifts~\cite{tirado_andres_clock_sources_2019}, yet no existing approach provides mechanisms for continuous self-improvement or retrospective correction. Finally, state-of-the-art solutions are either closed-source~\cite{graham_nsdi22} or tied to proprietary infrastructure~\cite{huygens_nsdi2018_geng_svm_nanosec, sundial_osdi2020}; there is a clear need for an accessible precision software clock on commodity hardware~\cite{najafi_hotos2021_time}.

Time series foundation models offer a new capability at this intersection. Pre-trained on billions of diverse time series samples, transformer-based models such as Chronos~\cite{Chronos} and TimesFM~\cite{TimesFM} learn generalizable temporal patterns that transfer to unseen domains without per-device training or fine-tuning. Their native multivariate support captures joint dynamics across multiple input channels, and their probabilistic outputs provide calibrated prediction intervals alongside point forecasts. Critically, these models operate through continuous inference on streaming data rather than static curve fitting, enabling a shift from reactive clock correction to predictive estimation. Much as DLSS~\cite{nvidia_dlss3_frame_generation_neural} synthesizes high-frame-rate video from sparse rendered frames through learned temporal dynamics, foundation models can increase the effective synchronization frequency by predicting drift between correction events using only commodity sensor streams. Open pre-trained weights make such systems reproducible and accessible. Despite this convergence of capabilities, no prior work has applied time series foundation models to oscillator drift prediction on commodity hardware.

We present ChronoTick, a system that applies zero-shot time series foundation models to predict and correct oscillator drift on commodity hardware, requiring no per-device calibration and no specialized infrastructure. ChronoTick runs multiple foundation models in parallel, fusing their predictions through inverse variance weighting and refining estimates retrospectively as new sensor data arrives. It consumes multivariate input from Linux hwmon sensor streams, including thermal zones, CPU frequency, and system load, and integrates directly with chrony for real-time NTP correction. Across heterogeneous platforms and without per-device training, ChronoTick achieves 0.604\,ms mean absolute error and 2.5 to 3 times better temporal consistency than commodity NTP, with 94.9\% prediction interval coverage.

This paper makes the following contributions:
\begin{enumerate}
\item \textbf{Zero-shot foundation model drift prediction.} First application of pre-trained time series foundation models to commodity oscillator compensation, eliminating per-device calibration entirely.
\item \textbf{Self-improving prediction pipeline.} A multi-model architecture with retrospective correction that adapts continuously to crystal aging and environmental changes without manual recalibration.
\item \textbf{Multivariate compensation from commodity sensors.} Integration of multiple hardware monitoring streams to capture the joint dynamics that single-sensor approaches miss.
\item \textbf{Open-source release.} We release ChronoTick publicly.
\end{enumerate}
