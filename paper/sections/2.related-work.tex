\section{Background and Related Work}

\subsection{Clock Synchronization Fundamentals}

Commodity servers rely on quartz crystal oscillators whose frequency drifts with temperature, supply voltage, and aging~\cite{tirado_andres_clock_sources_2019}. The Network Time Protocol (NTP)~\cite{ntp} compensates for this drift through a hierarchical stratum architecture in which clients periodically exchange timestamps with upstream servers. Each exchange yields four timestamps, from which the client estimates its offset as $o = ((t_2 - t_1) + (t_3 - t_4)) / 2$, where $t_1$ and $t_4$ are recorded by the local clock and $t_2$ and $t_3$ by the server. Modern implementations such as chrony achieve 1--10\,ms accuracy on local-area networks through statistical filtering of successive exchanges~\cite{ntp_performance_chrony_ntpd}. However, software timestamping introduces jitter from operating system scheduling and network stack traversal, and asymmetric network paths produce systematic errors that the four-timestamp model cannot distinguish from clock offset. These are design tradeoffs rather than failures: NTP prioritizes ubiquitous deployment on general-purpose networks over maximum precision.

The Precision Time Protocol (PTP, IEEE~1588)~\cite{ptp} closes this accuracy gap by timestamping packets at the MAC layer before operating system involvement, eliminating software-induced jitter. Realizing PTP's sub-microsecond accuracy requires substantial infrastructure investment: PTP-capable network interface cards, switches with transparent clock support, GPS-disciplined grandmaster clocks, and strict network topology control to maintain the symmetric paths PTP assumes~\cite{ptp_hardware_costs_survey, meta_ptp_time_appliances}. Extensions from White Rabbit~\cite{whiterabbit} to Google's TrueTime~\cite{spanner_osdi2012_truetime_gps_atomic} push accuracy further with specialized hardware. These solutions deliver excellent accuracy but confine high-precision timing to controlled environments. Between NTP's millisecond accuracy and PTP's sub-microsecond capability lies a three-order-of-magnitude precision gap that affects edge deployments, heterogeneous clusters, and any environment where dedicated timing hardware is impractical. Software-defined compensation of the local oscillator offers a path to bridge this gap using sensors already present on commodity hardware.

\subsection{Software Clock Compensation}

The temperature-frequency relationship of quartz oscillators has been exploited for compensation for decades. Chrony's \texttt{tempcomp} directive applies a quadratic polynomial to a single \texttt{hwmon} sensor reading, yielding a 3.54$\times$ improvement in offset standard deviation~\cite{ntp_performance_chrony_ntpd}. Commodity motherboards expose thermal sensors through the Linux \texttt{hwmon} subsystem, making software-defined compensation practical without additional hardware. However, clock drift is not governed by temperature alone; supply voltage fluctuations, crystal aging, and workload-induced thermal transients all contribute to frequency instability~\cite{tirado_andres_clock_sources_2019}, and a single quadratic polynomial over one sensor can capture only a fraction of this complexity.

In a landmark study, Graham~\cite{graham_nsdi22} demonstrated that automatically fitting cubic polynomials to DIMM temperature readings reduces commodity oscillator drift by up to three orders of magnitude, from 200\,ppm to approximately 100\,ppb. A key finding was that DIMM temperature sensors serve as better proxies for crystal temperature than CPU die sensors, because the memory modules sit closer to the oscillator on the motherboard and exhibit lower thermal lag. Each device requires individual calibration over approximately 48 hours because manufacturing variance in AT-cut angle produces unique temperature-frequency curves. Once fitted, Graham's polynomial remains fixed; it relies on a single sensor and does not adapt to changing thermal conditions, aging, or workload shifts. The system provides no uncertainty bounds on its predictions and was not released as open source, limiting opportunities for community extension and adaptation to new hardware platforms. Najafi et al. later argued that the systems community urgently needs better open-source timing tools~\cite{najafi_hotos2021_time}, a call that remains largely unanswered.

Beyond software compensation, alternative approaches trade different resources for different guarantees. Google's TrueTime provides bounded clock uncertainty through GPS receivers and atomic clocks~\cite{spanner_osdi2012_truetime_gps_atomic}, achieving nanosecond-level precision at the cost of specialized hardware. Systems such as CockroachDB~\cite{cockroachdb_hlc_implementation} and YugabyteDB~\cite{yugabytedb_hlc_distributed} avoid the hardware cost entirely by using Hybrid Logical Clocks for causal consistency, but sacrifice real-time semantics.

\subsection{Machine Learning for Timing Prediction}

Across multiple timing domains, learned models have achieved substantial gains over analytical baselines. In satellite clock prediction, LSTM and attention-augmented architectures have achieved 72-84\% improvement over polynomial baselines~\cite{he_bds3_lstm_72pct_arima, wang_lstm_attention_bds_2024, li_multivariate_cnn_lstm_gps_2024}, a trend confirmed by recent surveys~\cite{gnss_clock_prediction_review_2025}. In the oscillator domain, Su et al.~\cite{su_lstm_tcxo_transfer_learning} applied LSTM with transfer learning to TCXO compensation, reducing calibration requirements while improving accuracy by 51\%. At the hardware level, Jung et al.~\cite{jung_ml_rco_isscc_2022} achieved 0.68\,ppm/$^\circ$C stability through ML-based RC oscillator calibration, demonstrating that learned compensation has begun crossing from software into silicon.

Within datacenter timing, Huygens~\cite{huygens_nsdi2018_geng_svm_nanosec} applied support vector machines to filter network jitter, achieving tens-of-nanoseconds accuracy, far exceeding what software compensation alone can deliver. However, Huygens operates reactively on current synchronization error rather than predicting future drift, and requires PTP-capable hardware timestamps as input, positioning it as a complementary technique for environments with timing infrastructure rather than a commodity-hardware solution. Notably, every approach in this trajectory trains task-specific models from scratch on domain-specific data; none leverages pre-trained foundation models that generalize across domains without per-task training.

\subsection{Time Series Foundation Models}

Time series foundation models (TSFMs) represent a shift from per-task training to zero-shot generalization on unseen domains. Early work repurposed large language models for temporal prediction~\cite{TIME-LLM, TEMPO, AutoTimes}, and TimeGPT-1~\cite{TimeGPT-1} demonstrated that purpose-built foundation models achieve accurate zero-shot forecasts without domain-specific training. Pre-trained on large, diverse corpora, modern TSFMs address the three key dimensions identified in software clock compensation. First, zero-shot prediction eliminates per-device calibration: Chronos~\cite{Chronos} and MOMENT~\cite{MOMENT} achieve this through tokenization and masked modeling respectively, while TimesFM~\cite{TimesFM}, pretrained on 100 billion real-world time points, extends zero-shot capability to long-horizon forecasting. Second, multivariate input handling addresses the single-sensor limitation: MOIRAI~\cite{MOIRAI} processes arbitrary numbers of input channels through any-variate attention, and several architectures explicitly model exogenous covariates and cross-dimensional dependencies~\cite{Crossformer, TTMs, TimeXer, PatchTST}. Third, probabilistic forecasts provide the uncertainty bounds that polynomial approaches cannot offer: TimesFM produces native quantile outputs, and Time-MoE~\cite{Time-MoE} maintains both point and probabilistic prediction quality at billion-parameter scale.

To our knowledge, no prior work has applied pre-trained, zero-shot time series foundation models to commodity server oscillator drift prediction. ChronoTick bridges this gap.
